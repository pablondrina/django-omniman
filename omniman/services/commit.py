"""
CommitService — Fecha sessões e cria Orders.
"""

from __future__ import annotations

import logging
from datetime import datetime, timedelta
from decimal import Decimal

from django.db import transaction
from django.utils import timezone

from omniman import registry
from omniman.exceptions import CommitError, IdempotencyCacheHit, SessionError, ValidationError
from omniman.ids import generate_order_ref
from omniman.models import Directive, IdempotencyKey, Order, OrderEvent, OrderItem, Session
from omniman.monetary import monetary_mult


logger = logging.getLogger(__name__)


class CommitService:
    """
    Serviço para fechar sessões e criar Orders.

    Pipeline:
    1. Check idempotency (return cached if exists)
    2. Validate session is open
    3. Check required checks are fresh
    4. Check no blocking issues
    5. Run validators (stage="commit")
    6. Create Order + OrderItems
    7. Mark session as committed
    8. Enqueue post-commit directives
    9. Cache response in IdempotencyKey
    """

    @staticmethod
    def commit(
        session_key: str,
        channel_code: str,
        idempotency_key: str,
        ctx: dict | None = None,
    ) -> dict:
        """
        Fecha uma sessão e cria um Order.

        Args:
            session_key: Chave da sessão
            channel_code: Código do canal
            idempotency_key: Chave de idempotência
            ctx: Contexto adicional

        Returns:
            dict com order_ref e dados do pedido

        Raises:
            CommitError: Se commit falhar
            SessionError: Se sessão não encontrada
        """
        ctx = ctx or {}
        idem_scope = f"commit:{channel_code}"

        # 1. Check/create idempotency key (outside main transaction)
        try:
            idem = CommitService._acquire_idempotency_lock(idem_scope, idempotency_key)
        except IdempotencyCacheHit as cache_hit:
            # Cached response from previous successful commit
            return cache_hit.cached_response

        try:
            # 2. Execute commit in atomic transaction
            response = CommitService._do_commit(
                session_key=session_key,
                channel_code=channel_code,
                idempotency_key=idempotency_key,
                ctx=ctx,
            )

            # 3. Mark idempotency key as done (outside transaction)
            idem.status = "done"
            idem.response_body = response
            idem.response_code = 201
            idem.save(update_fields=["status", "response_body", "response_code"])

            return response

        except (CommitError, SessionError, ValidationError):
            # Mark idempotency key as failed (persists even if transaction rolled back)
            idem.status = "failed"
            idem.save(update_fields=["status"])
            raise

        except Exception as e:
            # Unexpected error - mark as failed and re-raise
            idem.status = "failed"
            idem.save(update_fields=["status"])
            logger.exception(f"Unexpected error in commit: {e}")
            raise

    @staticmethod
    def _acquire_idempotency_lock(scope: str, key: str) -> IdempotencyKey:
        """
        Acquire idempotency lock for a commit operation.

        Returns:
            IdempotencyKey with status="in_progress"

        Raises:
            IdempotencyCacheHit: If key exists and has cached response (not an error)
            CommitError: If key is already in progress
        """
        with transaction.atomic():
            try:
                idem = IdempotencyKey.objects.select_for_update(nowait=False).get(
                    scope=scope,
                    key=key,
                )
                # Key exists - check status
                if idem.status == "done" and idem.response_body:
                    raise IdempotencyCacheHit(idem.response_body)
                elif idem.status == "in_progress":
                    if idem.expires_at and idem.expires_at <= timezone.now():
                        # Orphaned key — allow retry
                        idem.status = "in_progress"
                        idem.expires_at = timezone.now() + timedelta(hours=24)
                        idem.save(update_fields=["status", "expires_at"])
                        return idem
                    raise CommitError(
                        code="in_progress",
                        message="Commit já está em andamento com esta chave",
                    )
                # Status is "failed" - allow retry
                idem.status = "in_progress"
                idem.save(update_fields=["status"])
                return idem

            except IdempotencyKey.DoesNotExist:
                # Create new key
                idem, created = IdempotencyKey.objects.get_or_create(
                    scope=scope,
                    key=key,
                    defaults={
                        "status": "in_progress",
                        "expires_at": timezone.now() + timedelta(hours=24),
                    },
                )
                if not created:
                    # Race condition: another request created it - re-check with lock
                    idem = IdempotencyKey.objects.select_for_update().get(pk=idem.pk)
                    if idem.status == "done" and idem.response_body:
                        raise IdempotencyCacheHit(idem.response_body)
                    elif idem.status == "in_progress":
                        raise CommitError(
                            code="in_progress",
                            message="Commit já está em andamento com esta chave",
                        )
                    # Status is "failed" - allow retry
                    idem.status = "in_progress"
                    idem.save(update_fields=["status"])
                return idem

    @staticmethod
    @transaction.atomic
    def _do_commit(
        session_key: str,
        channel_code: str,
        idempotency_key: str,
        ctx: dict,
    ) -> dict:
        """
        Execute the actual commit logic in an atomic transaction.
        """
        # Lock session
        try:
            session = Session.objects.select_for_update().get(
                session_key=session_key,
                channel__code=channel_code,
            )
        except Session.DoesNotExist:
            raise SessionError(
                code="not_found",
                message=f"Sessão não encontrada: {channel_code}:{session_key}",
            )

        channel = session.channel

        # Validate session is open
        if session.state == "committed":
            # Return existing order (idempotency)
            order = Order.objects.filter(session_key=session_key, channel=channel).first()
            if order:
                return {"order_ref": order.ref, "status": "already_committed"}
            raise CommitError(code="already_committed", message="Sessão já foi fechada")

        if session.state == "abandoned":
            raise CommitError(code="abandoned", message="Sessão foi abandonada")

        # Check required checks are fresh
        required_checks = channel.config.get("required_checks_on_commit", [])
        checks = session.data.get("checks", {})
        now = timezone.now()

        for check_code in required_checks:
            check = checks.get(check_code)
            if not check:
                raise CommitError(
                    code="missing_check",
                    message=f"Check obrigatório não encontrado: {check_code}",
                    context={"check_code": check_code},
                )
            if check.get("rev") != session.rev:
                raise CommitError(
                    code="stale_check",
                    message=f"Check desatualizado: {check_code}",
                    context={
                        "check_code": check_code,
                        "check_rev": check.get("rev"),
                        "session_rev": session.rev,
                    },
                )
            result = check.get("result") or {}
            deadline = result.get("hold_expires_at")
            if deadline:
                expires_dt = CommitService._parse_iso_datetime(deadline)
                if expires_dt is not None and expires_dt <= now:
                    raise CommitError(
                        code="hold_expired",
                        message="Reserva expirada para este check.",
                        context={"check_code": check_code, "expires_at": deadline},
                    )
            for hold in result.get("holds", []):
                expires_at = hold.get("expires_at")
                if not expires_at:
                    continue
                expires_dt = CommitService._parse_iso_datetime(expires_at)
                if expires_dt is not None and expires_dt <= now:
                    raise CommitError(
                        code="hold_expired",
                        message="Reserva expirada para este check.",
                        context={"check_code": check_code, "hold_id": hold.get("hold_id"), "expires_at": expires_at},
                    )

        # Check no blocking issues
        issues = session.data.get("issues", [])
        blocking = [i for i in issues if i.get("blocking")]
        if blocking:
            raise CommitError(
                code="blocking_issues",
                message="Existem issues bloqueantes",
                context={"issues": blocking},
            )

        # Run validators (stage="commit")
        for validator in registry.get_validators(stage="commit"):
            validator.validate(channel=channel, session=session, ctx=ctx)

        # H08: Validate session has items before commit
        if not session.items:
            raise CommitError(
                code="empty_session",
                message="Sessão sem itens não pode ser confirmada",
                context={"session_key": session_key},
            )

        # Create Order + OrderItems
        order = Order.objects.create(
            ref=generate_order_ref(),
            channel=channel,
            session_key=session_key,
            handle_type=session.handle_type,
            handle_ref=session.handle_ref,
            status=Order.Status.NEW,
            snapshot={
                "items": session.items,
                "data": session.data,
                "pricing": session.pricing,
                "rev": session.rev,
            },
            total_q=CommitService._calculate_total(session.items),
        )

        for item in session.items:
            # Usa line_total_q existente ou calcula se não existir
            line_total = item.get("line_total_q")
            if line_total is None:
                line_total = monetary_mult(Decimal(str(item["qty"])), item.get("unit_price_q", 0))

            OrderItem.objects.create(
                order=order,
                line_id=item["line_id"],
                sku=item["sku"],
                name=item.get("name", ""),
                qty=Decimal(str(item["qty"])),
                unit_price_q=item.get("unit_price_q", 0),
                line_total_q=int(line_total),
                meta=item.get("meta", {}),
            )

        # Create event
        OrderEvent.objects.create(
            order=order,
            type="created",
            actor=ctx.get("actor", "system"),
            payload={"from_session": session_key},
        )

        # Mark session as committed
        session.state = "committed"
        session.committed_at = timezone.now()
        session.commit_token = idempotency_key
        session.save()

        # Enqueue post-commit directives
        post_commit_directives = channel.config.get("post_commit_directives", [])
        stock_holds = None
        stock_check = checks.get("stock")
        if stock_check:
            stock_holds = (stock_check.get("result") or {}).get("holds")
        for topic in post_commit_directives:
            payload = {
                "order_ref": order.ref,
                "channel_code": channel.code,
                "session_key": session.session_key,
            }
            if topic == "stock.commit" and stock_holds:
                payload["holds"] = stock_holds
            Directive.objects.create(
                topic=topic,
                payload=payload,
            )

        return {
            "order_ref": order.ref,
            "order_id": order.pk,
            "status": "committed",
            "total_q": order.total_q,
            "items_count": len(session.items),
        }

    @staticmethod
    def _calculate_total(items: list[dict]) -> int:
        """
        Calcula total do pedido.

        Usa line_total_q se existir (pode ter sido calculado com lógica
        customizada como descontos). Se não existir, calcula qty * unit_price_q.
        """
        total = 0
        for item in items:
            line_total = item.get("line_total_q")
            if line_total is not None:
                total += int(line_total)
            else:
                qty = Decimal(str(item.get("qty", 0)))
                price = item.get("unit_price_q", 0)
                total += monetary_mult(qty, price)
        return total

    @staticmethod
    def _parse_iso_datetime(value: str | None) -> datetime | None:
        """
        Parse ISO datetime string to timezone-aware datetime.

        If the input has no timezone info, it's assumed to be in UTC
        (not the server's local timezone) to ensure consistent behavior
        regardless of server configuration.
        """
        if not value:
            return None
        try:
            dt = datetime.fromisoformat(value)
        except ValueError:
            return None
        if timezone.is_naive(dt):
            # Assume UTC for naive datetimes (safer than assuming local TZ)
            # Using datetime.timezone.utc (stdlib, no pytz needed)
            from datetime import timezone as dt_timezone
            dt = dt.replace(tzinfo=dt_timezone.utc)
        return dt
