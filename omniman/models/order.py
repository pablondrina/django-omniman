from __future__ import annotations

from django.db import models, transaction
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from .session import DecimalEncoder


class Order(models.Model):
    """
    Pedido canônico (selado, imutável).

    O snapshot contém o estado da Session no momento do commit para validação futura.

    Status Canônicos (semânticos):
    - new: Pedido recebido, aguardando processamento
    - confirmed: Confirmado (disponibilidade OK, pagamento pode estar pendente ou já recebido)
    - processing: Em preparação/produção
    - ready: Pronto para retirada/despacho
    - dispatched: Em trânsito (só para delivery)
    - delivered: Entregue ao destinatário
    - completed: Finalizado com sucesso
    - cancelled: Cancelado (qualquer motivo)
    - returned: Devolvido (pós-entrega)

    Fluxos por Tipo de Canal:

    1. Canal Externo (iFood, Rappi):
       Pedido chega → NEW → CONFIRMED (auto, já vem pago)
       → PROCESSING → READY → DISPATCHED → COMPLETED
       Bridge traduz eventos externos para transições.

    2. E-commerce (Shop):
       Intenção → NEW → (validar disponibilidade) → CONFIRMED → (pagamento)
       → PROCESSING → READY → [DISPATCHED] → COMPLETED
       DISPATCHED só se for entrega.

    3. PDV (Point of Sale):
       Venda → NEW → CONFIRMED → COMPLETED (quase imediato)
       Fluxo simplificado, geralmente síncrono.

    Customização por Canal:
    - Channel.config["order_flow"]["transitions"]: Transições permitidas
    - Channel.config["order_flow"]["terminal_statuses"]: Status terminais
    - Channel.config["status_labels"]: Terminologia operacional (ex: "Em Preparo")
    - Channel.config["auto_transitions"]["on_create"]: Auto-transição ao criar

    Timestamps de Lifecycle:
    Cada transição grava automaticamente o timestamp correspondente (confirmed_at, etc.)
    para B.I. e auditoria. OrderEvent mantém o audit log completo.

    Extensão Futura (REVIEW):
    Se surgir necessidade de validação de alternativas quando produto indisponível,
    pode-se adicionar status "review" entre NEW e CONFIRMED:
    NEW → REVIEW (alternativas sugeridas) → CONFIRMED (usuário aprova)
    Por ora, não implementado - validação de disponibilidade é feita antes do commit.
    """

    class Status(models.TextChoices):
        """Status canônicos do pedido."""
        NEW = "new", _("novo")
        CONFIRMED = "confirmed", _("confirmado")
        PROCESSING = "processing", _("em preparo")
        READY = "ready", _("pronto")
        DISPATCHED = "dispatched", _("despachado")
        DELIVERED = "delivered", _("entregue")
        COMPLETED = "completed", _("concluído")
        CANCELLED = "cancelled", _("cancelado")
        RETURNED = "returned", _("devolvido")

    # Aliases para retrocompatibilidade
    STATUS_NEW = Status.NEW
    STATUS_CONFIRMED = Status.CONFIRMED
    STATUS_PROCESSING = Status.PROCESSING
    STATUS_READY = Status.READY
    STATUS_DISPATCHED = Status.DISPATCHED
    STATUS_DELIVERED = Status.DELIVERED
    STATUS_COMPLETED = Status.COMPLETED
    STATUS_CANCELLED = Status.CANCELLED
    STATUS_RETURNED = Status.RETURNED
    STATUS_CHOICES = Status.choices

    # Transições padrão (usado quando canal não define order_flow)
    DEFAULT_TRANSITIONS = {
        Status.NEW: [Status.CONFIRMED, Status.CANCELLED],
        Status.CONFIRMED: [Status.PROCESSING, Status.READY, Status.CANCELLED],
        Status.PROCESSING: [Status.READY, Status.CANCELLED],
        Status.READY: [Status.DISPATCHED, Status.COMPLETED],
        Status.DISPATCHED: [Status.DELIVERED, Status.RETURNED],
        Status.DELIVERED: [Status.COMPLETED, Status.RETURNED],
        Status.COMPLETED: [],
        Status.CANCELLED: [],
        Status.RETURNED: [Status.COMPLETED],
    }

    TERMINAL_STATUSES = [Status.COMPLETED, Status.CANCELLED]

    ref = models.CharField(_("referência"), max_length=64, unique=True)
    channel = models.ForeignKey(
        "omniman.Channel", verbose_name=_("canal de venda"), on_delete=models.PROTECT
    )
    session_key = models.CharField(_("chave da sessão"), max_length=64, db_index=True, default="")

    handle_type = models.CharField(_("tipo de identificação"), max_length=32, null=True, blank=True)
    handle_ref = models.CharField(_("identificador"), max_length=64, null=True, blank=True)
    external_ref = models.CharField(_("referência externa"), max_length=128, null=True, blank=True, db_index=True)

    status = models.CharField(
        _("status"),
        max_length=32,
        choices=Status.choices,
        default=Status.NEW,
        db_index=True,
    )

    snapshot = models.JSONField(_("snapshot"), default=dict, blank=True, encoder=DecimalEncoder)

    currency = models.CharField(_("moeda"), max_length=3, default="BRL")
    total_q = models.BigIntegerField(_("total (q)"), default=0)

    # Timestamps de lifecycle (para B.I. e auditoria)
    created_at = models.DateTimeField(_("criado em"), auto_now_add=True)
    updated_at = models.DateTimeField(_("atualizado em"), auto_now=True)
    confirmed_at = models.DateTimeField(_("confirmado em"), null=True, blank=True)
    processing_at = models.DateTimeField(_("em preparo em"), null=True, blank=True)
    ready_at = models.DateTimeField(_("pronto em"), null=True, blank=True)
    dispatched_at = models.DateTimeField(_("despachado em"), null=True, blank=True)
    delivered_at = models.DateTimeField(_("entregue em"), null=True, blank=True)
    completed_at = models.DateTimeField(_("concluído em"), null=True, blank=True)
    cancelled_at = models.DateTimeField(_("cancelado em"), null=True, blank=True)

    class Meta:
        app_label = "omniman"
        verbose_name = _("pedido")
        verbose_name_plural = _("pedidos")
        ordering = ("-created_at", "id")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._original_status = self.status

    def __str__(self) -> str:
        if self.handle_ref and self.handle_type:
            handle_type = (
                str(self.handle_type)
                .replace("_", " ")
                .replace("-", " ")
                .strip()
                .title()
            )
            return f"{handle_type}: {self.handle_ref}"
        return self.ref

    # ------------------------------------------------------------------ status

    def get_transitions(self) -> dict[str, list[str]]:
        """Retorna o mapa de transições do canal ou o padrão."""
        flow = (self.channel.config or {}).get("order_flow", {})
        return flow.get("transitions", self.DEFAULT_TRANSITIONS)

    def get_terminal_statuses(self) -> list[str]:
        """Retorna os status terminais do canal ou o padrão."""
        flow = (self.channel.config or {}).get("order_flow", {})
        return flow.get("terminal_statuses", self.TERMINAL_STATUSES)

    def get_allowed_transitions(self) -> list[str]:
        """Retorna os próximos status válidos a partir do status atual."""
        transitions = self.get_transitions()
        return transitions.get(self.status, [])

    def can_transition_to(self, new_status: str) -> bool:
        """Verifica se a transição para new_status é permitida."""
        return new_status in self.get_allowed_transitions()

    # Mapeamento status → campo timestamp
    STATUS_TIMESTAMP_FIELDS = {
        STATUS_CONFIRMED: "confirmed_at",
        STATUS_PROCESSING: "processing_at",
        STATUS_READY: "ready_at",
        STATUS_DISPATCHED: "dispatched_at",
        STATUS_DELIVERED: "delivered_at",
        STATUS_COMPLETED: "completed_at",
        STATUS_CANCELLED: "cancelled_at",
    }

    def save(self, *args, **kwargs):
        # OM4: State machine enforcement — impede transições inválidas via save()
        if self.pk and self.status != self._original_status:
            from omniman.exceptions import InvalidTransition

            transitions = self.get_transitions()
            allowed = transitions.get(self._original_status, [])
            if self.status not in allowed:
                raise InvalidTransition(
                    code="invalid_transition",
                    message=f"Transição {self._original_status} → {self.status} não permitida",
                    context={
                        "current_status": self._original_status,
                        "requested_status": self.status,
                        "allowed_transitions": allowed,
                    },
                )

        super().save(*args, **kwargs)
        self._original_status = self.status

    @transaction.atomic
    def transition_status(self, new_status: str, actor: str = "system") -> None:
        """
        Transiciona o status do pedido validando regras do canal.

        Args:
            new_status: Novo status desejado
            actor: Identificador de quem está fazendo a transição

        Raises:
            InvalidTransition: Se a transição não for permitida
        """
        from omniman.exceptions import InvalidTransition

        # Lock the row to prevent concurrent transitions
        order = Order.objects.select_for_update().get(pk=self.pk)

        # Verifica se está em status terminal
        if order.status in order.get_terminal_statuses():
            raise InvalidTransition(
                code="terminal_status",
                message=f"Pedido em status terminal '{order.status}' não permite transições",
                context={"current_status": order.status, "requested_status": new_status},
            )

        # Verifica se a transição é permitida
        allowed = order.get_allowed_transitions()
        if new_status not in allowed:
            raise InvalidTransition(
                code="invalid_transition",
                message=f"Transição {order.status} → {new_status} não permitida",
                context={
                    "current_status": order.status,
                    "requested_status": new_status,
                    "allowed_transitions": allowed,
                },
            )

        old_status = order.status
        order.status = new_status

        # Atualiza timestamp do novo status
        update_fields = ["status", "updated_at"]
        ts_field = self.STATUS_TIMESTAMP_FIELDS.get(new_status)
        if ts_field and getattr(order, ts_field) is None:
            setattr(order, ts_field, timezone.now())
            update_fields.append(ts_field)

        order.save(update_fields=update_fields)

        # Refresh self from the locked row
        self.status = order.status
        self._original_status = order.status
        for field in update_fields:
            if field not in ("updated_at",):
                setattr(self, field, getattr(order, field))

        # Registra evento
        self.emit_event(
            event_type="status_changed",
            actor=actor,
            payload={
                "old_status": old_status,
                "new_status": new_status,
            },
        )

    def emit_event(self, event_type: str, actor: str = "system", payload: dict | None = None) -> OrderEvent:
        """
        Emite um evento no audit log do pedido.

        Args:
            event_type: Tipo do evento (ex: "status_changed", "note_added")
            actor: Identificador de quem gerou o evento
            payload: Dados adicionais do evento

        Returns:
            OrderEvent criado
        """
        return OrderEvent.objects.create(
            order=self,
            type=event_type,
            actor=actor,
            payload=payload or {},
        )


class OrderItem(models.Model):
    """
    Item de um pedido.
    """

    order = models.ForeignKey(Order, verbose_name=_("pedido"), on_delete=models.CASCADE, related_name="items")

    line_id = models.CharField(_("ID da linha"), max_length=64)
    sku = models.CharField(_("SKU"), max_length=64)
    name = models.CharField(_("nome"), max_length=200, blank=True, default="")

    qty = models.DecimalField(_("quantidade"), max_digits=12, decimal_places=3)
    unit_price_q = models.BigIntegerField(_("preço unitário (q)"))
    line_total_q = models.BigIntegerField(_("total da linha (q)"))

    meta = models.JSONField(_("metadados"), default=dict, blank=True)

    class Meta:
        app_label = "omniman"
        verbose_name = _("item do pedido")
        verbose_name_plural = _("itens do pedido")
        constraints = [
            models.UniqueConstraint(
                fields=["order", "line_id"],
                name="uniq_order_item_line_id",
            ),
            models.CheckConstraint(
                condition=models.Q(qty__gt=0),
                name="order_item_qty_positive",
            ),
        ]

    def __str__(self) -> str:
        return f"{self.sku} x {self.qty}"


class OrderEvent(models.Model):
    """
    Audit log append-only para pedidos.
    """

    order = models.ForeignKey(Order, verbose_name=_("pedido"), on_delete=models.CASCADE, related_name="events")

    type = models.CharField(_("tipo"), max_length=64, db_index=True)
    actor = models.CharField(_("ator"), max_length=128)
    payload = models.JSONField(_("payload"), default=dict)

    created_at = models.DateTimeField(_("criado em"), auto_now_add=True)

    class Meta:
        app_label = "omniman"
        verbose_name = _("evento do pedido")
        verbose_name_plural = _("eventos do pedido")
        ordering = ("created_at",)

    def __str__(self) -> str:
        return f"{self.type} @ {self.created_at}"
